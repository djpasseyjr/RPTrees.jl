<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>RPTrees.jl · RPTrees.jl Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">RPTrees.jl Documentation</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>RPTrees.jl</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Build-an-Index"><span>Build an Index</span></a></li><li><a class="tocitem" href="#KNN-Graphs"><span>KNN-Graphs</span></a></li><li><a class="tocitem" href="#Threading"><span>Threading</span></a></li><li><a class="tocitem" href="#Benchmarks"><span>Benchmarks</span></a></li><li><a class="tocitem" href="#Function-Documentation"><span>Function Documentation</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>RPTrees.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>RPTrees.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/djpasseyjr/RPTrees.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="RPTrees.jl"><a class="docs-heading-anchor" href="#RPTrees.jl">RPTrees.jl</a><a id="RPTrees.jl-1"></a><a class="docs-heading-anchor-permalink" href="#RPTrees.jl" title="Permalink"></a></h1><p><img src="https://github.com/djpasseyjr/RPTrees.jl/raw/main/docs/src/images/rppartition.png" alt="Random Projection Splits"/></p><p><code>RPTrees</code> is a Julia package for building ensembles of random projection trees. Random projection trees are a generalization of KD-Trees and are used to quickly approximate nearest neighbors or build k-nearest-neighbor graphs. They <a href="https://cseweb.ucsd.edu/~dasgupta/papers/rptree-stoc.pdf">conform to low dimensionality</a> that is often present in high dimensional data.</p><p>The implementation here is based on the <a href="https://helda.helsinki.fi//bitstream/handle/10138/301147/Hyvonen_Pitkanen_2016_Fast_Nearest.pdf?sequence=1">MRPT algorithm</a>. This package also includes optimizations for knn-graph creation and has built-in support for multithreading.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>To install just type</p><pre><code class="language-jl">] add https://github.com/djpasseyjr/RPTrees.jl</code></pre><p>in the REPL or </p><pre><code class="language-jl">using Pkg
Pkg.add(path=&quot;https://github.com/djpasseyjr/RPTrees.jl&quot;)</code></pre><h2 id="Build-an-Index"><a class="docs-heading-anchor" href="#Build-an-Index">Build an Index</a><a id="Build-an-Index-1"></a><a class="docs-heading-anchor-permalink" href="#Build-an-Index" title="Permalink"></a></h2><p>To build an ensemble of random projection trees use the <code>RPForest</code> type.</p><pre><code class="language-jl">X = rand(100, 10000)
rpf = RPForest(X; depth=6, ntrees=5)</code></pre><p>The type accepts a matrix of data, <code>X</code> where each column represents a datapoint. </p><ol><li><code>depth</code> describes the number of times each random projection tree will split the data. Leaf nodes in the tree contain <code>npoints / 2^depth</code> data points. Increasing <code>depth</code> increases speed but decreases accuracy.</li><li><code>ntrees</code> controls the number of trees in the ensemble. More trees means more accuracy but more memory.</li></ol><p>To query the index use</p><pre><code class="language-jl">k = 10
q = X[:, 1]
ann = approx_knn(rpf, q, k; vote_cutoff=2)</code></pre><ol><li>The <code>vote_cutoff</code> parameter signifies how many &quot;votes&quot; a point needs in order to be included in a linear search. Each tree &quot;votes&quot; for the points a leaf node, so if there aren&#39;t many point in the leaves and there aren&#39;t many trees, the odds of a point receiving more than one vote is low.  Increasing <code>vote_cutoff</code> speeds up the algorithm but may reduce accuracy. When <code>depth</code> is large and <code>ntrees</code> is less than 5, it is reccomended to set <code>vote_cutoff = 1</code>. </li></ol><h2 id="KNN-Graphs"><a class="docs-heading-anchor" href="#KNN-Graphs">KNN-Graphs</a><a id="KNN-Graphs-1"></a><a class="docs-heading-anchor-permalink" href="#KNN-Graphs" title="Permalink"></a></h2><p>This package was designed specifically to generate k-nearest-neighbor graphs and has specialized functions for this purpose. It uses neighbor of neighbor exploration (outlined <a href="https://arxiv.org/pdf/1602.00370.pdf">here</a>) to efficiently improve the accuracy of a knn-graph.</p><p>Nearest neighbor graphs are used to give a sparse topology to large datasets. Their structure can be used to <a href="https://arxiv.org/pdf/1602.00370.pdf">project the data</a> onto a lower dimensional manifold, to cluster datapoints with community detection algorithms or to preform other analyses.</p><p>To generate nearest neighbor graphs:</p><pre><code class="language-jl">X = rand(100, 10000)
rpf = RPForest(X; depth=6, ntrees=5)
k = 10
g = knngraph(rpf, k; vote_cutoff=1, ne_iters=1, gtype=SimpleDiGraph)</code></pre><ol><li>The <code>vote_cutoff</code> parameter signifies how many &quot;votes&quot; a point needs in order to be included in a linear search.</li><li><code>ne_iters</code> controlls how many iterations of neighbor exploration the algorithm will undergo. Successive iterations are increasingly fast. It is reccomened to use more iterations of neighbor exploration when the number of trees is small and less when many trees are used.</li><li>The <code>gtype</code> parameter allows the user to specify a <code>LightGraphs.jl</code> graph type to return. <code>gtype=identity</code> returns a sparse adjacency matrix.</li></ol><p>If an array of nearest neighbor indices is preferred,</p><pre><code class="language-jl">nn = allknn(rpf, k; vote_cutoff=1, ne_iters=0)</code></pre><p>can be used to generate an <code>rpf.npoints</code>x<code>k</code> array of integer indexes where <code>nn[i, :]</code> corresponds to the nearest neighbors of <code>X[:, i]</code>. The keyword arguments work as outlined above.</p><h2 id="Threading"><a class="docs-heading-anchor" href="#Threading">Threading</a><a id="Threading-1"></a><a class="docs-heading-anchor-permalink" href="#Threading" title="Permalink"></a></h2><p><code>RPTrees</code> has built in support for multithreading. To allocate multiple threads, start <code>julia</code> with the <code>--threads</code> flag:</p><pre><code class="language-console">user@sys:~$ julia --threads 4</code></pre><p>To see this at work, consider a small scale example:</p><pre><code class="language-console">user@sys:~$ cmd=&quot;using RPTrees; rpf=RPForest(rand(100, 10000)); @time knngraph(rpf, 10, ne_iters=1)&quot;
user@sys:~$ julia -e &quot;$cmd&quot;
29.422300 seconds (140.91 M allocations: 8.520 GiB, 5.86% gc time)
user@sys:~$ julia -e --threads 4 &quot;$cmd&quot;
15.212044 seconds (141.42 M allocations: 8.840 GiB, 5.98% gc time)</code></pre><p>(This assumes that <code>RPTrees</code> is installed.)</p><h2 id="Benchmarks"><a class="docs-heading-anchor" href="#Benchmarks">Benchmarks</a><a id="Benchmarks-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmarks" title="Permalink"></a></h2><p><img src="images/benchplot.png" alt="Benchmark Plot"/></p><h2 id="Function-Documentation"><a class="docs-heading-anchor" href="#Function-Documentation">Function Documentation</a><a id="Function-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Documentation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RPTrees.RPForest-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T" href="#RPTrees.RPForest-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T"><code>RPTrees.RPForest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">RPForest(data::Array{T, 2}, depth::Int, ntrees::Int) where T -&gt; ensemble</code></pre><p>Constructor for ensemble of sparse random projection trees with voting. Follows the implementation outlined in:</p><blockquote><p><strong>Fast Nearest Neighbor Search through Sparse Random Projections and Voting.</strong> Ville Hyvönen, Teemu Pitkänen, Sotirios Tasoulis, Elias Jääsaari, Risto Tuomainen, Liang Wang, Jukka Ilmari Corander, Teemu Roos. Proceedings of the 2016 IEEE Conference on Big Data (2016)</p></blockquote></div><a class="docs-sourcelink" target="_blank" href="https://github.com/djpasseyjr/RPTrees.jl/blob/ddab21c51b67c0873a3002502ab1392469df4544/src/rptree.jl#L29-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RPTrees.approx_knn-Union{Tuple{T}, Tuple{RPForest{T}, AbstractMatrix{T}, Int64}} where T" href="#RPTrees.approx_knn-Union{Tuple{T}, Tuple{RPForest{T}, AbstractMatrix{T}, Int64}} where T"><code>RPTrees.approx_knn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">approx_knn(rpf::RPForest{T}, q::Array{T, 2}, k::Int; vote_cutoff=1) where T -&gt; knn_idx</code></pre><p>For a query point <code>q</code>, find the approximate <code>k</code> nearest neighbors from the data stored in the the RPForest. The <code>vote_cutoff</code> parameter signifies how many &quot;votes&quot; a point needs in order to be included in a linear search. Increasing <code>vote_cutoff</code> speeds up the algorithm but may reduce accuracy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/djpasseyjr/RPTrees.jl/blob/ddab21c51b67c0873a3002502ab1392469df4544/src/nearest_neighbors.jl#L159-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RPTrees.knngraph-Union{Tuple{G}, Tuple{T}, Tuple{RPForest{T}, Int64}} where {T, G}" href="#RPTrees.knngraph-Union{Tuple{G}, Tuple{T}, Tuple{RPForest{T}, Int64}} where {T, G}"><code>RPTrees.knngraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">knngraph(rpf::RPForest{T}, k::Int, vote_cutoff; vote_cutoff::Int=1, ne_iters::Int=0, gtype::G) where {T, G} -&gt; g</code></pre><p>Returns a graph with <code>rpf.npoints</code> node and <code>k * rpf.npoints</code> edges datapoints conneceted to nearest neighbors</p><p><strong>Parameters</strong></p><ol><li><code>rpf</code>: random forest of the desired data</li><li><code>k</code>: the desired number of nearest neighbors</li><li><code>vote_cutoff</code>: signifies how many &quot;votes&quot; a point needs in order to be included </li></ol><p>in a linear search through leaf nodes. Increasing <code>vote_cutoff</code> speeds up the algorithm but may reduce accuracy. Defaults to 1</p><ol><li><code>ne_iters</code>: assigns the number of iterations of neighbor exploration to use. Defaults to zero.</li></ol><p>Neighbor exploration is a way to increse knn-graph accuracy.</p><ol><li><code>gtype</code> is the type of graph to construct. Defaults to <code>SimpleDiGraph</code>. <code>gtype=identity</code> returns a sparse adjacency matrix.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/djpasseyjr/RPTrees.jl/blob/ddab21c51b67c0873a3002502ab1392469df4544/src/nearest_neighbors.jl#L296-L311">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>explore(i::Int, data::AbstractArray{T}, ann::Array{NeighborExplorer{T}, 1}) where T</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="RPTrees.allknn-Union{Tuple{T}, Tuple{RPForest{T}, Int64}} where T" href="#RPTrees.allknn-Union{Tuple{T}, Tuple{RPForest{T}, Int64}} where T"><code>RPTrees.allknn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">allknn(rpf::RPForest{T}, k::Int; vote_cutoff::Int=1, ne_iters::Int=0) where T -&gt; approxnn</code></pre><p>Returns a <code>rpf.npoints</code> by <code>k</code> array of approximate nearest neighbor indexes. That is, <code>approxnn[i,:]</code> contains the indexes of the k nearest neighbors of <code>rpf.data[:, i]</code>.</p><p>The <code>ne_iters</code> assigns the number of iterations of neighbor exploration to use.  Neighbor exploration is an inexpensive way to increase accuracy.</p><p>The <code>vote_cutoff</code> parameter signifies how many &quot;votes&quot; a point needs in order to be included  in a linear search. Increasing <code>vote_cutoff</code> speeds up the algorithm but may reduce accuracy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/djpasseyjr/RPTrees.jl/blob/ddab21c51b67c0873a3002502ab1392469df4544/src/nearest_neighbors.jl#L257-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RPTrees.traverse_to_leaves-Union{Tuple{T}, Tuple{RPForest{T}, Matrix{T}}} where T" href="#RPTrees.traverse_to_leaves-Union{Tuple{T}, Tuple{RPForest{T}, Matrix{T}}} where T"><code>RPTrees.traverse_to_leaves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">traverse_to_leaves(rpf::RPForest{T}, x::Array{T, 2}) where T -&gt; leaf_idxs</code></pre><p>Route data point <code>x</code> down to a leaf node each tree and return and array of indexes of the data stored in each corresponding leaf node</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/djpasseyjr/RPTrees.jl/blob/ddab21c51b67c0873a3002502ab1392469df4544/src/nearest_neighbors.jl#L1-L6">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 27 April 2021 13:14">Tuesday 27 April 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
